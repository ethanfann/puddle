#!/usr/bin/env bash
set -euo pipefail

VERSION="0.1.0"
TOKEN=""
API_BASE="https://api.raindrop.io/rest/v1"  # Will be used in command implementations

usage() {
  cat <<EOF
puddle - CLI for Raindrop.io bookmarks

Usage: puddle <command> [options]

Commands:
  ls [search]              List/search bookmarks
  get <id>                 Get a single bookmark
  add <url>                Add a new bookmark
  update <id>              Update a bookmark
  rm <id>                  Delete a bookmark
  tag add|rm <tag>         Bulk tag operations
  move <collection-id>     Bulk move bookmarks
  collections              List all collections

Global Options:
  --token <token>          API token (overrides env/config)
  --version                Show version
  --help                   Show this help

Environment:
  RAINDROP_TOKEN           API token (or ~/.config/puddle/token)

Examples:
  puddle ls '#react'
  puddle add 'https://example.com' --title 'Example' --tags 'a,b'
  puddle get 12345
  puddle rm 12345
EOF
}

# Parse global options first
while [[ $# -gt 0 ]]; do
  case "$1" in
    --version)
      echo "$VERSION"
      exit 0
      ;;
    --help|-h)
      usage
      exit 0
      ;;
    --token)
      shift
      if [[ $# -eq 0 ]]; then
        echo '{"error": "missing_value", "message": "--token requires a value"}' >&2
        exit 1
      fi
      TOKEN="$1"
      shift
      ;;
    *)
      break
      ;;
  esac
done

# If no command provided, show usage
if [[ $# -eq 0 ]]; then
  usage
  exit 0
fi

# Load token if not already set by --token flag
if [[ -z "$TOKEN" ]]; then
  # Check environment variable
  if [[ -n "${RAINDROP_TOKEN:-}" ]]; then
    TOKEN="$RAINDROP_TOKEN"
  # Check config file
  elif [[ -f "$HOME/.config/puddle/token" ]]; then
    TOKEN=$(cat "$HOME/.config/puddle/token" | tr -d '\n')
  fi
fi

# Verify token exists
if [[ -z "$TOKEN" ]]; then
  echo '{"error": "missing_token", "message": "No token found. Set RAINDROP_TOKEN env var, create ~/.config/puddle/token file, or use --token flag"}' >&2
  exit 1
fi

# Helper: make API request
api_request() {
  local method="$1"
  local endpoint="$2"
  local data="${3:-}"
  
  local curl_args=(
    -s
    -X "$method"
    -H "Authorization: Bearer $TOKEN"
    -H "Content-Type: application/json"
  )
  
  if [[ -n "$data" ]]; then
    curl_args+=(-d "$data")
  fi
  
  local response http_code body
  response=$(curl "${curl_args[@]}" -w "\n%{http_code}" "$API_BASE$endpoint")
  http_code=$(echo "$response" | tail -n1)
  body=$(echo "$response" | sed '$d')
  
  if [[ "$http_code" -ge 200 && "$http_code" -lt 300 ]]; then
    echo "$body"
    return 0
  elif [[ "$http_code" == "404" ]]; then
    echo "{\"error\": \"not_found\", \"message\": \"Resource not found\", \"status\": $http_code}" >&2
    return 3
  elif [[ "$http_code" -ge 400 && "$http_code" -lt 500 ]]; then
    echo "{\"error\": \"api_error\", \"message\": \"API error\", \"status\": $http_code}" >&2
    return 2
  else
    echo "{\"error\": \"network_error\", \"message\": \"Request failed\", \"status\": $http_code}" >&2
    return 1
  fi
}

# Command: ls [search]
cmd_ls() {
  local search=""
  local collection="0"
  local page="0"
  local perpage="25"
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --collection)
        shift
        if [[ $# -eq 0 || "$1" == --* ]]; then
          echo '{"error": "missing_value", "message": "--collection requires a value"}' >&2
          return 1
        fi
        collection="$1"
        shift
        ;;
      --page)
        shift
        if [[ $# -eq 0 || "$1" == --* ]]; then
          echo '{"error": "missing_value", "message": "--page requires a value"}' >&2
          return 1
        fi
        page="$1"
        shift
        ;;
      --perpage)
        shift
        if [[ $# -eq 0 || "$1" == --* ]]; then
          echo '{"error": "missing_value", "message": "--perpage requires a value"}' >&2
          return 1
        fi
        perpage="$1"
        shift
        ;;
      *)
        search="$1"
        shift
        ;;
    esac
  done
  
  local endpoint="/raindrops/$collection"
  local params=()
  
  if [[ -n "$search" ]]; then
    # URL encode the search string
    local encoded_search
    encoded_search=$(printf '%s' "$search" | jq -sRr @uri)
    params+=("search=$encoded_search")
  fi
  params+=("page=$page")
  params+=("perpage=$perpage")
  
  local query_string
  query_string=$(printf "%s&" "${params[@]}" | sed 's/&$//')
  endpoint="$endpoint?$query_string"
  
  local response
  if response=$(api_request GET "$endpoint"); then
    echo "$response" | jq '.items'
  else
    return $?
  fi
}

# Command dispatch
cmd="${1:-}"
shift || true

case "$cmd" in
  ls)
    cmd_ls "$@"
    ;;
  get|add|update|rm|tag|move|collections)
    echo "{\"error\": \"not_implemented\", \"message\": \"Command '$cmd' not yet implemented\"}" >&2
    exit 1
    ;;
  *)
    echo "{\"error\": \"unknown_command\", \"message\": \"Unknown command: $cmd\"}" >&2
    exit 1
    ;;
esac
