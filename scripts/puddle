#!/usr/bin/env bash
set -euo pipefail

VERSION="0.1.0"
TOKEN=""
JSON_ERRORS=false
API_BASE="https://api.raindrop.io/rest/v1"

usage() {
  cat <<EOF
puddle - CLI for Raindrop.io bookmarks

Usage: puddle <command> [options]

Commands:
  ls [search]              List/search bookmarks
  get <id>                 Get a single bookmark
  add <url>                Add a new bookmark
  update <id>              Update a bookmark
  rm <id>                  Delete a bookmark
  tag add|rm <tag>         Bulk tag operations
  move <collection-id>     Bulk move bookmarks
  collections              List all collections

Global Options:
  --token <token>          API token (overrides env/config)
  --json                   Output errors as JSON (for scripting)
  --version                Show version
  --help                   Show this help

Environment:
  RAINDROP_TOKEN           API token (or ~/.config/puddle/token)

Examples:
  puddle ls '#react'
  puddle add 'https://example.com' --title 'Example' --tags 'a,b'
  puddle get 12345
  puddle rm 12345
EOF
}

# Parse global options first
while [[ $# -gt 0 ]]; do
  case "$1" in
    --version)
      echo "$VERSION"
      exit 0
      ;;
    --help|-h)
      usage
      exit 0
      ;;
    --token)
      shift
      if [[ $# -eq 0 ]]; then
        echo 'Error: --token requires a value' >&2
        exit 1
      fi
      TOKEN="$1"
      shift
      ;;
    --json)
      JSON_ERRORS=true
      shift
      ;;
    *)
      break
      ;;
  esac
done

# Helper: output error message
error() {
  local code="$1"
  local type="$2"
  local message="$3"
  
  if [[ "$JSON_ERRORS" == "true" ]]; then
    echo "{\"error\": \"$type\", \"message\": \"$message\"}" >&2
  else
    echo "Error: $message" >&2
  fi
  return "$code"
}

# Helper: require flag value - checks next arg exists and isn't another flag
# Usage: require_flag_value "$1" "$#" "flag_name" || return 1
# Returns 0 if valid, 1 if missing/invalid
require_flag_value() {
  local value="$1"
  local remaining="$2"
  local flag="$3"
  
  if [[ "$remaining" -eq 0 || "$value" == --* ]]; then
    error 1 "missing_value" "$flag requires a value"
    return 1
  fi
  return 0
}

# Helper: parse comma-separated tags to JSON array
# Usage: tags_json=$(parse_tags "a,b,c")
parse_tags() {
  echo "$1" | tr ',' '\n' | jq -R . | jq -s .
}

# Helper: add string field to JSON payload
# Usage: payload=$(json_add_string "$payload" "field" "$value")
json_add_string() {
  local json="$1"
  local field="$2"
  local value="$3"
  echo "$json" | jq --arg v "$value" ". + {\"$field\": \$v}"
}

# Helper: add number/json field to JSON payload
# Usage: payload=$(json_add_json "$payload" "field" "$json_value")
json_add_json() {
  local json="$1"
  local field="$2"
  local value="$3"
  echo "$json" | jq --argjson v "$value" ". + {\"$field\": \$v}"
}

# If no command provided, show usage
if [[ $# -eq 0 ]]; then
  usage
  exit 0
fi

# Load token if not already set by --token flag
if [[ -z "$TOKEN" ]]; then
  # Check environment variable
  if [[ -n "${RAINDROP_TOKEN:-}" ]]; then
    TOKEN="$RAINDROP_TOKEN"
  # Check config file
  elif [[ -f "$HOME/.config/puddle/token" ]]; then
    TOKEN=$(cat "$HOME/.config/puddle/token" | tr -d '\n')
  fi
fi

# Verify token exists
if [[ -z "$TOKEN" ]]; then
  error 1 "missing_token" "No token found. Set RAINDROP_TOKEN env var, create ~/.config/puddle/token file, or use --token flag"
  exit 1
fi

# Helper: make API request
api_request() {
  local method="$1"
  local endpoint="$2"
  local data="${3:-}"
  
  local curl_args=(
    -s
    -X "$method"
    -H "Authorization: Bearer $TOKEN"
    -H "Content-Type: application/json"
  )
  
  if [[ -n "$data" ]]; then
    curl_args+=(-d "$data")
  fi
  
  local response http_code body
  response=$(curl "${curl_args[@]}" -w "\n%{http_code}" "$API_BASE$endpoint")
  http_code=$(echo "$response" | tail -n1)
  body=$(echo "$response" | sed '$d')
  
  if [[ "$http_code" -ge 200 && "$http_code" -lt 300 ]]; then
    echo "$body"
    return 0
  elif [[ "$http_code" == "404" ]]; then
    error 3 "not_found" "Resource not found (HTTP $http_code)"
    return 3
  elif [[ "$http_code" -ge 400 && "$http_code" -lt 500 ]]; then
    error 2 "api_error" "API error (HTTP $http_code)"
    return 2
  else
    error 1 "network_error" "Request failed (HTTP $http_code)"
    return 1
  fi
}

# Command: ls [search]
cmd_ls() {
  local search=""
  local collection="0"
  local page="0"
  local perpage="25"
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --collection)
        shift
        require_flag_value "${1:-}" "$#" "--collection" || return 1
        collection="$1"; shift
        ;;
      --page)
        shift
        require_flag_value "${1:-}" "$#" "--page" || return 1
        page="$1"; shift
        ;;
      --perpage)
        shift
        require_flag_value "${1:-}" "$#" "--perpage" || return 1
        perpage="$1"; shift
        ;;
      *)
        search="$1"
        shift
        ;;
    esac
  done
  
  local endpoint="/raindrops/$collection"
  local params=()
  
  if [[ -n "$search" ]]; then
    # URL encode the search string
    local encoded_search
    encoded_search=$(printf '%s' "$search" | jq -sRr @uri)
    params+=("search=$encoded_search")
  fi
  params+=("page=$page")
  params+=("perpage=$perpage")
  
  local query_string
  query_string=$(printf "%s&" "${params[@]}" | sed 's/&$//')
  endpoint="$endpoint?$query_string"
  
  local response
  if response=$(api_request GET "$endpoint"); then
    echo "$response" | jq '.items'
  else
    return $?
  fi
}

# Command: get <id>
cmd_get() {
  if [[ $# -eq 0 ]]; then
    error 1 "missing_argument" "Usage: puddle get <id>"
    return 1
  fi
  
  local id="$1"
  
  # Validate id is numeric
  if ! [[ "$id" =~ ^[0-9]+$ ]]; then
    error 3 "invalid_id" "Bookmark ID must be numeric"
    return 3
  fi
  
  local response
  if response=$(api_request GET "/raindrop/$id"); then
    echo "$response" | jq '.item'
  else
    return $?
  fi
}

# Command: add <url>
cmd_add() {
  if [[ $# -eq 0 ]]; then
    error 1 "missing_argument" "Usage: puddle add <url> [--title ...] [--tags ...] [--collection ...] [--excerpt ...]"
    return 1
  fi
  
  local url=""
  local title=""
  local tags=""
  local collection=""
  local excerpt=""
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --title)
        shift
        require_flag_value "${1:-}" "$#" "--title" || return 1
        title="$1"; shift
        ;;
      --tags)
        shift
        require_flag_value "${1:-}" "$#" "--tags" || return 1
        tags="$1"; shift
        ;;
      --collection)
        shift
        require_flag_value "${1:-}" "$#" "--collection" || return 1
        collection="$1"; shift
        ;;
      --excerpt)
        shift
        require_flag_value "${1:-}" "$#" "--excerpt" || return 1
        excerpt="$1"; shift
        ;;
      *)
        if [[ -z "$url" ]]; then
          url="$1"
        fi
        shift
        ;;
    esac
  done
  
  # Validate URL
  if [[ -z "$url" ]]; then
    error 1 "missing_url" "URL is required"
    return 1
  fi
  
  # Basic URL validation
  if ! [[ "$url" =~ ^https?:// ]]; then
    error 1 "invalid_url" "URL must start with http:// or https://"
    return 1
  fi
  
  # Build JSON payload
  local payload
  payload=$(jq -n --arg url "$url" '{link: $url}')
  
  [[ -n "$title" ]] && payload=$(json_add_string "$payload" "title" "$title")
  [[ -n "$tags" ]] && payload=$(json_add_json "$payload" "tags" "$(parse_tags "$tags")")
  [[ -n "$collection" ]] && payload=$(json_add_json "$payload" "collection" "{\"\$id\": $collection}")
  [[ -n "$excerpt" ]] && payload=$(json_add_string "$payload" "excerpt" "$excerpt")
  
  local response
  if response=$(api_request POST "/raindrop" "$payload"); then
    echo "$response" | jq '.item'
  else
    return $?
  fi
}

# Command: update <id>
cmd_update() {
  if [[ $# -eq 0 ]]; then
    error 1 "missing_argument" "Usage: puddle update <id> [--title ...] [--note ...] [--tags ...] [--excerpt ...] [--collection ...] [--important true|false]"
    return 1
  fi
  
  local id=""
  local title=""
  local note=""
  local tags=""
  local excerpt=""
  local collection=""
  local important=""
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --title)
        shift
        require_flag_value "${1:-}" "$#" "--title" || return 1
        title="$1"; shift
        ;;
      --note)
        shift
        require_flag_value "${1:-}" "$#" "--note" || return 1
        note="$1"; shift
        ;;
      --tags)
        shift
        require_flag_value "${1:-}" "$#" "--tags" || return 1
        tags="$1"; shift
        ;;
      --excerpt)
        shift
        require_flag_value "${1:-}" "$#" "--excerpt" || return 1
        excerpt="$1"; shift
        ;;
      --collection)
        shift
        require_flag_value "${1:-}" "$#" "--collection" || return 1
        collection="$1"; shift
        ;;
      --important)
        shift
        require_flag_value "${1:-}" "$#" "--important" || return 1
        important="$1"; shift
        ;;
      *)
        if [[ -z "$id" ]]; then
          id="$1"
        fi
        shift
        ;;
    esac
  done
  
  # Validate id
  if [[ -z "$id" ]]; then
    error 1 "missing_id" "Bookmark ID is required"
    return 1
  fi
  
  if ! [[ "$id" =~ ^[0-9]+$ ]]; then
    error 3 "invalid_id" "Bookmark ID must be numeric"
    return 3
  fi
  
  # Build JSON payload
  local payload='{}'
  
  [[ -n "$title" ]] && payload=$(json_add_string "$payload" "title" "$title")
  [[ -n "$note" ]] && payload=$(json_add_string "$payload" "note" "$note")
  [[ -n "$tags" ]] && payload=$(json_add_json "$payload" "tags" "$(parse_tags "$tags")")
  [[ -n "$excerpt" ]] && payload=$(json_add_string "$payload" "excerpt" "$excerpt")
  [[ -n "$collection" ]] && payload=$(json_add_json "$payload" "collection" "{\"\$id\": $collection}")
  
  if [[ -n "$important" ]]; then
    if [[ "$important" == "true" ]]; then
      payload=$(json_add_json "$payload" "important" "true")
    elif [[ "$important" == "false" ]]; then
      payload=$(json_add_json "$payload" "important" "false")
    else
      error 1 "invalid_value" "--important must be true or false"
      return 1
    fi
  fi
  
  local response
  if response=$(api_request PUT "/raindrop/$id" "$payload"); then
    echo "$response" | jq '.item'
  else
    return $?
  fi
}

# Command: rm <id>
cmd_rm() {
  if [[ $# -eq 0 ]]; then
    error 1 "missing_argument" "Usage: puddle rm <id>"
    return 1
  fi
  
  local id="$1"
  
  # Validate id is numeric
  if ! [[ "$id" =~ ^[0-9]+$ ]]; then
    error 3 "invalid_id" "Bookmark ID must be numeric"
    return 3
  fi
  
  local response
  if response=$(api_request DELETE "/raindrop/$id"); then
    echo "$response" | jq '.item'
  else
    return $?
  fi
}

# Command: tag add|rm <tag> --search '...'
cmd_tag() {
  if [[ $# -lt 2 ]]; then
    error 1 "missing_argument" "Usage: puddle tag add|rm <tag> --search '...' [--collection N]"
    return 1
  fi
  
  local action="$1"
  shift
  
  if [[ "$action" != "add" && "$action" != "rm" ]]; then
    error 1 "invalid_action" "Tag action must be 'add' or 'rm'"
    return 1
  fi
  
  local tag=""
  local search=""
  local collection="0"
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --search)
        shift
        require_flag_value "${1:-}" "$#" "--search" || return 1
        search="$1"; shift
        ;;
      --collection)
        shift
        require_flag_value "${1:-}" "$#" "--collection" || return 1
        collection="$1"; shift
        ;;
      *)
        if [[ -z "$tag" ]]; then
          tag="$1"
        fi
        shift
        ;;
    esac
  done
  
  # Validate required args
  if [[ -z "$tag" ]]; then
    error 1 "missing_tag" "Tag name is required"
    return 1
  fi
  
  if [[ -z "$search" ]]; then
    error 1 "missing_search" "--search is required for bulk tag operations"
    return 1
  fi
  
  # Build payload based on action
  local payload
  if [[ "$action" == "add" ]]; then
    payload=$(jq -n --arg tag "$tag" '{tags: [$tag]}')
  else
    # rm action - use empty array with tag to remove
    payload=$(jq -n --arg tag "$tag" '{"$unset": {tags: [$tag]}}')
  fi
  
  # URL encode search
  local encoded_search
  encoded_search=$(printf '%s' "$search" | jq -sRr @uri)
  
  local endpoint="/raindrops/$collection?search=$encoded_search"
  
  local response
  if response=$(api_request PUT "$endpoint" "$payload"); then
    echo "$response" | jq '{modified: .modified, result: .result}'
  else
    return $?
  fi
}

# Command: move <collection-id> --search '...'
cmd_move() {
  if [[ $# -eq 0 ]]; then
    error 1 "missing_argument" "Usage: puddle move <target-collection-id> --search '...' [--collection N]"
    return 1
  fi
  
  local target_collection=""
  local search=""
  local source_collection="0"
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --search)
        shift
        require_flag_value "${1:-}" "$#" "--search" || return 1
        search="$1"; shift
        ;;
      --collection)
        shift
        require_flag_value "${1:-}" "$#" "--collection" || return 1
        source_collection="$1"; shift
        ;;
      *)
        if [[ -z "$target_collection" ]]; then
          target_collection="$1"
        fi
        shift
        ;;
    esac
  done
  
  # Validate required args
  if [[ -z "$target_collection" ]]; then
    error 1 "missing_collection" "Target collection ID is required"
    return 1
  fi
  
  # Validate target collection is numeric (can be negative for system collections)
  if ! [[ "$target_collection" =~ ^-?[0-9]+$ ]]; then
    error 1 "invalid_collection" "Collection ID must be numeric"
    return 1
  fi
  
  if [[ -z "$search" ]]; then
    error 1 "missing_search" "--search is required for bulk move operations"
    return 1
  fi
  
  # Build payload
  local payload
  payload=$(jq -n --argjson coll "$target_collection" '{collection: {"$id": $coll}}')
  
  # URL encode search
  local encoded_search
  encoded_search=$(printf '%s' "$search" | jq -sRr @uri)
  
  local endpoint="/raindrops/$source_collection?search=$encoded_search"
  
  local response
  if response=$(api_request PUT "$endpoint" "$payload"); then
    echo "$response" | jq '{modified: .modified, result: .result}'
  else
    return $?
  fi
}

# Command: collections
cmd_collections() {
  # Fetch root collections
  local root_response ret
  root_response=$(api_request GET "/collections") || ret=$?
  if [[ -n "${ret:-}" ]]; then
    return "$ret"
  fi
  
  # Fetch child collections
  local child_response
  child_response=$(api_request GET "/collections/childrens") || ret=$?
  if [[ -n "${ret:-}" ]]; then
    return "$ret"
  fi
  
  # Merge and filter out system collections (-1 Unsorted, -99 Trash)
  # Extract items from both responses, merge, and filter
  local root_items child_items
  root_items=$(echo "$root_response" | jq '.items // []')
  child_items=$(echo "$child_response" | jq '.items // []')
  
  # Combine arrays and filter out system collections
  echo "$root_items" "$child_items" | jq -s 'add | map(select(._id > 0))'
}

# Command dispatch
cmd="${1:-}"
shift || true

case "$cmd" in
  ls)
    cmd_ls "$@"
    ;;
  get)
    cmd_get "$@"
    ;;
  add)
    cmd_add "$@"
    ;;
  update)
    cmd_update "$@"
    ;;
  rm)
    cmd_rm "$@"
    ;;
  tag)
    cmd_tag "$@"
    ;;
  move)
    cmd_move "$@"
    ;;
  collections)
    cmd_collections "$@"
    ;;
  *)
    echo "{\"error\": \"unknown_command\", \"message\": \"Unknown command: $cmd\"}" >&2
    exit 1
    ;;
esac
