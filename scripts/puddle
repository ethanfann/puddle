#!/usr/bin/env bash
set -euo pipefail

VERSION="0.1.0"
TOKEN=""
API_BASE="https://api.raindrop.io/rest/v1"  # Will be used in command implementations

usage() {
  cat <<EOF
puddle - CLI for Raindrop.io bookmarks

Usage: puddle <command> [options]

Commands:
  ls [search]              List/search bookmarks
  get <id>                 Get a single bookmark
  add <url>                Add a new bookmark
  update <id>              Update a bookmark
  rm <id>                  Delete a bookmark
  tag add|rm <tag>         Bulk tag operations
  move <collection-id>     Bulk move bookmarks
  collections              List all collections

Global Options:
  --token <token>          API token (overrides env/config)
  --version                Show version
  --help                   Show this help

Environment:
  RAINDROP_TOKEN           API token (or ~/.config/puddle/token)

Examples:
  puddle ls '#react'
  puddle add 'https://example.com' --title 'Example' --tags 'a,b'
  puddle get 12345
  puddle rm 12345
EOF
}

# Parse global options first
while [[ $# -gt 0 ]]; do
  case "$1" in
    --version)
      echo "$VERSION"
      exit 0
      ;;
    --help|-h)
      usage
      exit 0
      ;;
    --token)
      shift
      if [[ $# -eq 0 ]]; then
        echo '{"error": "missing_value", "message": "--token requires a value"}' >&2
        exit 1
      fi
      TOKEN="$1"
      shift
      ;;
    *)
      break
      ;;
  esac
done

# If no command provided, show usage
if [[ $# -eq 0 ]]; then
  usage
  exit 0
fi

# Load token if not already set by --token flag
if [[ -z "$TOKEN" ]]; then
  # Check environment variable
  if [[ -n "${RAINDROP_TOKEN:-}" ]]; then
    TOKEN="$RAINDROP_TOKEN"
  # Check config file
  elif [[ -f "$HOME/.config/puddle/token" ]]; then
    TOKEN=$(cat "$HOME/.config/puddle/token" | tr -d '\n')
  fi
fi

# Verify token exists
if [[ -z "$TOKEN" ]]; then
  echo '{"error": "missing_token", "message": "No token found. Set RAINDROP_TOKEN env var, create ~/.config/puddle/token file, or use --token flag"}' >&2
  exit 1
fi

# Helper: make API request
api_request() {
  local method="$1"
  local endpoint="$2"
  local data="${3:-}"
  
  local curl_args=(
    -s
    -X "$method"
    -H "Authorization: Bearer $TOKEN"
    -H "Content-Type: application/json"
  )
  
  if [[ -n "$data" ]]; then
    curl_args+=(-d "$data")
  fi
  
  local response http_code body
  response=$(curl "${curl_args[@]}" -w "\n%{http_code}" "$API_BASE$endpoint")
  http_code=$(echo "$response" | tail -n1)
  body=$(echo "$response" | sed '$d')
  
  if [[ "$http_code" -ge 200 && "$http_code" -lt 300 ]]; then
    echo "$body"
    return 0
  elif [[ "$http_code" == "404" ]]; then
    echo "{\"error\": \"not_found\", \"message\": \"Resource not found\", \"status\": $http_code}" >&2
    return 3
  elif [[ "$http_code" -ge 400 && "$http_code" -lt 500 ]]; then
    echo "{\"error\": \"api_error\", \"message\": \"API error\", \"status\": $http_code}" >&2
    return 2
  else
    echo "{\"error\": \"network_error\", \"message\": \"Request failed\", \"status\": $http_code}" >&2
    return 1
  fi
}

# Command: ls [search]
cmd_ls() {
  local search=""
  local collection="0"
  local page="0"
  local perpage="25"
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --collection)
        shift
        if [[ $# -eq 0 || "$1" == --* ]]; then
          echo '{"error": "missing_value", "message": "--collection requires a value"}' >&2
          return 1
        fi
        collection="$1"
        shift
        ;;
      --page)
        shift
        if [[ $# -eq 0 || "$1" == --* ]]; then
          echo '{"error": "missing_value", "message": "--page requires a value"}' >&2
          return 1
        fi
        page="$1"
        shift
        ;;
      --perpage)
        shift
        if [[ $# -eq 0 || "$1" == --* ]]; then
          echo '{"error": "missing_value", "message": "--perpage requires a value"}' >&2
          return 1
        fi
        perpage="$1"
        shift
        ;;
      *)
        search="$1"
        shift
        ;;
    esac
  done
  
  local endpoint="/raindrops/$collection"
  local params=()
  
  if [[ -n "$search" ]]; then
    # URL encode the search string
    local encoded_search
    encoded_search=$(printf '%s' "$search" | jq -sRr @uri)
    params+=("search=$encoded_search")
  fi
  params+=("page=$page")
  params+=("perpage=$perpage")
  
  local query_string
  query_string=$(printf "%s&" "${params[@]}" | sed 's/&$//')
  endpoint="$endpoint?$query_string"
  
  local response
  if response=$(api_request GET "$endpoint"); then
    echo "$response" | jq '.items'
  else
    return $?
  fi
}

# Command: get <id>
cmd_get() {
  if [[ $# -eq 0 ]]; then
    echo '{"error": "missing_argument", "message": "Usage: puddle get <id>"}' >&2
    return 1
  fi
  
  local id="$1"
  
  # Validate id is numeric
  if ! [[ "$id" =~ ^[0-9]+$ ]]; then
    echo '{"error": "invalid_id", "message": "Bookmark ID must be numeric"}' >&2
    return 3
  fi
  
  local response
  if response=$(api_request GET "/raindrop/$id"); then
    echo "$response" | jq '.item'
  else
    return $?
  fi
}

# Command: add <url>
cmd_add() {
  if [[ $# -eq 0 ]]; then
    echo '{"error": "missing_argument", "message": "Usage: puddle add <url> [--title ...] [--tags ...] [--collection ...] [--excerpt ...]"}' >&2
    return 1
  fi
  
  local url=""
  local title=""
  local tags=""
  local collection=""
  local excerpt=""
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --title)
        shift
        if [[ $# -eq 0 || "$1" == --* ]]; then
          echo '{"error": "missing_value", "message": "--title requires a value"}' >&2
          return 1
        fi
        title="$1"
        shift
        ;;
      --tags)
        shift
        if [[ $# -eq 0 || "$1" == --* ]]; then
          echo '{"error": "missing_value", "message": "--tags requires a value"}' >&2
          return 1
        fi
        tags="$1"
        shift
        ;;
      --collection)
        shift
        if [[ $# -eq 0 || "$1" == --* ]]; then
          echo '{"error": "missing_value", "message": "--collection requires a value"}' >&2
          return 1
        fi
        collection="$1"
        shift
        ;;
      --excerpt)
        shift
        if [[ $# -eq 0 || "$1" == --* ]]; then
          echo '{"error": "missing_value", "message": "--excerpt requires a value"}' >&2
          return 1
        fi
        excerpt="$1"
        shift
        ;;
      *)
        if [[ -z "$url" ]]; then
          url="$1"
        fi
        shift
        ;;
    esac
  done
  
  # Validate URL
  if [[ -z "$url" ]]; then
    echo '{"error": "missing_url", "message": "URL is required"}' >&2
    return 1
  fi
  
  # Basic URL validation
  if ! [[ "$url" =~ ^https?:// ]]; then
    echo '{"error": "invalid_url", "message": "URL must start with http:// or https://"}' >&2
    return 1
  fi
  
  # Build JSON payload using jq
  local payload
  payload=$(jq -n --arg url "$url" '{link: $url}')
  
  if [[ -n "$title" ]]; then
    payload=$(echo "$payload" | jq --arg title "$title" '. + {title: $title}')
  fi
  
  if [[ -n "$tags" ]]; then
    # Convert comma-separated tags to JSON array
    local tags_array
    tags_array=$(echo "$tags" | tr ',' '\n' | jq -R . | jq -s .)
    payload=$(echo "$payload" | jq --argjson tags "$tags_array" '. + {tags: $tags}')
  fi
  
  if [[ -n "$collection" ]]; then
    payload=$(echo "$payload" | jq --argjson coll "$collection" '. + {collection: {"$id": $coll}}')
  fi
  
  if [[ -n "$excerpt" ]]; then
    payload=$(echo "$payload" | jq --arg excerpt "$excerpt" '. + {excerpt: $excerpt}')
  fi
  
  local response
  if response=$(api_request POST "/raindrop" "$payload"); then
    echo "$response" | jq '.item'
  else
    return $?
  fi
}

# Command: update <id>
cmd_update() {
  if [[ $# -eq 0 ]]; then
    echo '{"error": "missing_argument", "message": "Usage: puddle update <id> [--title ...] [--note ...] [--tags ...] [--excerpt ...] [--collection ...] [--important true|false]"}' >&2
    return 1
  fi
  
  local id=""
  local title=""
  local note=""
  local tags=""
  local excerpt=""
  local collection=""
  local important=""
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --title)
        shift
        if [[ $# -eq 0 || "$1" == --* ]]; then
          echo '{"error": "missing_value", "message": "--title requires a value"}' >&2
          return 1
        fi
        title="$1"
        shift
        ;;
      --note)
        shift
        if [[ $# -eq 0 || "$1" == --* ]]; then
          echo '{"error": "missing_value", "message": "--note requires a value"}' >&2
          return 1
        fi
        note="$1"
        shift
        ;;
      --tags)
        shift
        if [[ $# -eq 0 || "$1" == --* ]]; then
          echo '{"error": "missing_value", "message": "--tags requires a value"}' >&2
          return 1
        fi
        tags="$1"
        shift
        ;;
      --excerpt)
        shift
        if [[ $# -eq 0 || "$1" == --* ]]; then
          echo '{"error": "missing_value", "message": "--excerpt requires a value"}' >&2
          return 1
        fi
        excerpt="$1"
        shift
        ;;
      --collection)
        shift
        if [[ $# -eq 0 || "$1" == --* ]]; then
          echo '{"error": "missing_value", "message": "--collection requires a value"}' >&2
          return 1
        fi
        collection="$1"
        shift
        ;;
      --important)
        shift
        if [[ $# -eq 0 || "$1" == --* ]]; then
          echo '{"error": "missing_value", "message": "--important requires true or false"}' >&2
          return 1
        fi
        important="$1"
        shift
        ;;
      *)
        if [[ -z "$id" ]]; then
          id="$1"
        fi
        shift
        ;;
    esac
  done
  
  # Validate id
  if [[ -z "$id" ]]; then
    echo '{"error": "missing_id", "message": "Bookmark ID is required"}' >&2
    return 1
  fi
  
  if ! [[ "$id" =~ ^[0-9]+$ ]]; then
    echo '{"error": "invalid_id", "message": "Bookmark ID must be numeric"}' >&2
    return 3
  fi
  
  # Build JSON payload
  local payload='{}'
  
  if [[ -n "$title" ]]; then
    payload=$(echo "$payload" | jq --arg title "$title" '. + {title: $title}')
  fi
  
  if [[ -n "$note" ]]; then
    payload=$(echo "$payload" | jq --arg note "$note" '. + {note: $note}')
  fi
  
  if [[ -n "$tags" ]]; then
    local tags_array
    tags_array=$(echo "$tags" | tr ',' '\n' | jq -R . | jq -s .)
    payload=$(echo "$payload" | jq --argjson tags "$tags_array" '. + {tags: $tags}')
  fi
  
  if [[ -n "$excerpt" ]]; then
    payload=$(echo "$payload" | jq --arg excerpt "$excerpt" '. + {excerpt: $excerpt}')
  fi
  
  if [[ -n "$collection" ]]; then
    payload=$(echo "$payload" | jq --argjson coll "$collection" '. + {collection: {"$id": $coll}}')
  fi
  
  if [[ -n "$important" ]]; then
    if [[ "$important" == "true" ]]; then
      payload=$(echo "$payload" | jq '. + {important: true}')
    elif [[ "$important" == "false" ]]; then
      payload=$(echo "$payload" | jq '. + {important: false}')
    else
      echo '{"error": "invalid_value", "message": "--important must be true or false"}' >&2
      return 1
    fi
  fi
  
  local response
  if response=$(api_request PUT "/raindrop/$id" "$payload"); then
    echo "$response" | jq '.item'
  else
    return $?
  fi
}

# Command: rm <id>
cmd_rm() {
  if [[ $# -eq 0 ]]; then
    echo '{"error": "missing_argument", "message": "Usage: puddle rm <id>"}' >&2
    return 1
  fi
  
  local id="$1"
  
  # Validate id is numeric
  if ! [[ "$id" =~ ^[0-9]+$ ]]; then
    echo '{"error": "invalid_id", "message": "Bookmark ID must be numeric"}' >&2
    return 3
  fi
  
  local response
  if response=$(api_request DELETE "/raindrop/$id"); then
    echo "$response" | jq '.item'
  else
    return $?
  fi
}

# Command: tag add|rm <tag> --search '...'
cmd_tag() {
  if [[ $# -lt 2 ]]; then
    echo '{"error": "missing_argument", "message": "Usage: puddle tag add|rm <tag> --search '\''...'\'' [--collection N]"}' >&2
    return 1
  fi
  
  local action="$1"
  shift
  
  if [[ "$action" != "add" && "$action" != "rm" ]]; then
    echo '{"error": "invalid_action", "message": "Tag action must be '\''add'\'' or '\''rm'\''"}' >&2
    return 1
  fi
  
  local tag=""
  local search=""
  local collection="0"
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --search)
        shift
        if [[ $# -eq 0 || "$1" == --* ]]; then
          echo '{"error": "missing_value", "message": "--search requires a value"}' >&2
          return 1
        fi
        search="$1"
        shift
        ;;
      --collection)
        shift
        if [[ $# -eq 0 || "$1" == --* ]]; then
          echo '{"error": "missing_value", "message": "--collection requires a value"}' >&2
          return 1
        fi
        collection="$1"
        shift
        ;;
      *)
        if [[ -z "$tag" ]]; then
          tag="$1"
        fi
        shift
        ;;
    esac
  done
  
  # Validate required args
  if [[ -z "$tag" ]]; then
    echo '{"error": "missing_tag", "message": "Tag name is required"}' >&2
    return 1
  fi
  
  if [[ -z "$search" ]]; then
    echo '{"error": "missing_search", "message": "--search is required for bulk tag operations"}' >&2
    return 1
  fi
  
  # Build payload based on action
  local payload
  if [[ "$action" == "add" ]]; then
    payload=$(jq -n --arg tag "$tag" '{tags: [$tag]}')
  else
    # rm action - use empty array with tag to remove
    payload=$(jq -n --arg tag "$tag" '{"$unset": {tags: [$tag]}}')
  fi
  
  # URL encode search
  local encoded_search
  encoded_search=$(printf '%s' "$search" | jq -sRr @uri)
  
  local endpoint="/raindrops/$collection?search=$encoded_search"
  
  local response
  if response=$(api_request PUT "$endpoint" "$payload"); then
    echo "$response" | jq '{modified: .modified, result: .result}'
  else
    return $?
  fi
}

# Command dispatch
cmd="${1:-}"
shift || true

case "$cmd" in
  ls)
    cmd_ls "$@"
    ;;
  get)
    cmd_get "$@"
    ;;
  add)
    cmd_add "$@"
    ;;
  update)
    cmd_update "$@"
    ;;
  rm)
    cmd_rm "$@"
    ;;
  tag)
    cmd_tag "$@"
    ;;
  move|collections)
    echo "{\"error\": \"not_implemented\", \"message\": \"Command '$cmd' not yet implemented\"}" >&2
    exit 1
    ;;
  *)
    echo "{\"error\": \"unknown_command\", \"message\": \"Unknown command: $cmd\"}" >&2
    exit 1
    ;;
esac
